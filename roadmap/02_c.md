# C
> **Random Quote:** To understand the system, you must speak the language it dreams in. That language is C.

You can build operating systems in many languages, but if you want to understand what's happening beneath the abstractions, C is the language you need. This roadmap will guide you through C not as a general-purpose tool, but as the foundation for systems programming. You'll learn to think in terms of memory, pointers, and hardware-level logic, because in OS development, C isn't just a choice. It's the standard.

**Contents:**
+ [Why C for OS development?](#why-c-for-os-development)
+ [Toolchain Setup](#toolchain-setup)
+ [C Language Fundamentals](#c-language-fundamentals)
+ [Practical Exercises](#practical-exercises)
+ [C Without Standard Library](#c-without-standard-library)


## Why C for OS development?
+ Minimal runtime overhead.
+ Deterministic memory model.
+ Fine-grained control over memory and hardware.
+ Generates predictable machine code.
+ Widely supported by toolchains (e.g., GCC, Clang).

## Toolchain Setup
Learn how to and install the following:
+ GCC / Clang
+ `make`
+ A text editor (Sublime Text, NVim, VS code, etc.)

## C Language Fundamentals
You don't need to learn everything in C, just the parts relevant to systems programming:
+ Functions
+ Arrays & strings
+ Structs & unions (linked lists)
+ Data types & sizes
+ Pointers
+ Bitwise operations
+ Enums
+ `const`, `volatile`
+ Header files (`.h`)
+ Makefiles

## Practical Exercises
Avoid tutorial hell at all costs.

Exercise ideas:
+ Print "Hello World!" to `stdout` in a hosted environment.
+ Implement a custom `strlen()` or `memcpy()`.
+ Write and call functions with pointer parameters.
+ Print an array of hex bytes.
+ Bit manipulation: turn bits on/off in a `uint8-t`.
+ Create a `struct` for fictional device and access its fields.

## C Without Standard Library
